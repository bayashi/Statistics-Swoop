#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Statistics/Swoop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STATISTICS_SWOOP';
  package Statistics::Swoop;use strict;use warnings;use Carp qw/croak/;use Class::Accessor::Lite (rw=>[qw/list/],ro=>[qw/count max min range sum avg/],);our$VERSION='0.02';sub new {my ($class,$list)=@_;croak "first arg is required as array ref" unless ref($list)eq 'ARRAY';my$self=bless +{list=>$list,count=>scalar @{$list},}=>$class;$self->_calc if$self->count;return$self}sub _calc {my$self=shift;my$sum;my$max=$self->list->[0];my$min=$self->list->[0];my$range;my$avg;for my$i (@{$self->list}){$sum += $i;if ($max < $i){$max=$i}elsif ($min > $i){$min=$i}}if ($self->count==1){$self->{range}=$max;$self->{avg}=$max}elsif ($self->count > 1){$self->{range}=$max - $min;$self->{avg}=$sum / $self->count}$self->{sum}=$sum;$self->{max}=$max;$self->{min}=$min}sub maximum {$_[0]->max}sub minimum {$_[0]->min}sub average {$_[0]->avg}sub result {my$self=shift;return +{count=>$self->count,max=>$self->max,min=>$self->min,range=>$self->range,sum=>$self->sum,avg=>$self->avg,}}1;
STATISTICS_SWOOP

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;
use Statistics::Swoop;
use Getopt::Long qw/:config gnu_getopt/;
use Text::ASCIITable;

MAIN: {
    my $opt = {};
    get_opt($opt, @ARGV);
    swoop($opt);
}

sub swoop {
    my $opt = shift;

    my %list;
    while (my $stdin = <STDIN>) {
        chomp $stdin;
        next if !defined $stdin;
        next if $stdin eq '';
        if ($opt->{fields}) {
            my @f = split /$opt->{delimiter}/, $stdin;
            for my $field (@{$opt->{fields}}) {
                push @{$list{$field - 1}}, normalize($f[$field - 1]);
            }
        }
        else {
            push @{$list{0}}, normalize($stdin);
        }
    }

    my $t = Text::ASCIITable->new;
    $t->setCols('', qw/ elem sum max min range avg /);

    for my $field (@{$opt->{fields}}) {
        my $swoop = Statistics::Swoop->new(\@{$list{$field - 1}});
        $t->addRow(
            $field,
            defined $swoop->count ? $swoop->count : '-',
            defined $swoop->sum   ? $swoop->sum   : '-',
            defined $swoop->max   ? $swoop->max   : '-',
            defined $swoop->min   ? $swoop->min   : '-',
            defined $swoop->range ? $swoop->range : '-',
            defined $swoop->avg   ? $swoop->avg   : '-',
        );
    }
    if ($opt->{stderr}) {
        warn $t;
    }
    else {
        print $t;
    }
}

sub get_opt {
    my ($opt, @argv) = @_;

    Getopt::Long::GetOptionsFromArray(
        \@argv,
        'fields|f=s'    => \$opt->{fields},
        'delimiter|d=s' => \$opt->{delimiter},
        'stderr'        => \$opt->{stderr},
        'h|help' => sub {
            _show_usage(1);
        },
        'v|version' => sub {
            print "$0 $Statistics::Swoop::VERSION\n";
            exit 1;
        },
    ) or _show_usage(2);

    if (!$opt->{fields}) {
        push @{$opt->{_fields}}, 1;
    }
    else {
        for my $f (split /,/, $opt->{fields}) {
            push @{$opt->{_fields}}, $f;
        }
    }
    $opt->{fields} = $opt->{_fields};

    unless ($opt->{delimiter}) {
        $opt->{delimiter} = "\t";
    }
}

sub normalize {
    my $value = shift;

    $value =~ s/^([\d\.]+).*/$1/;
    return $value;
}

sub _show_usage {
    my $exitval = shift;

    require Pod::Usage;
    Pod::Usage::pod2usage(-exitval => $exitval);
}

__END__

=head1 NAME

swoop - getting basic stats of lines

=head1 SYNOPSIS

Getting stats of lines(sum, max, min, range, avg)

    $ cat some_file | swoop

=head2 EXAMPLES

specified the calc fields and the delimiter for splitting lines

    $ cat some_file | swoop -f1,3 -d,

output

    .--------------------------------------------.
    |   | elem | sum  | max | min | range | avg  |
    +---+------+------+-----+-----+-------+------+
    | 1 |   10 | 40.7 |   9 |   0 |     9 | 4.07 |
    | 3 |   10 |   55 |  10 |   1 |     9 |  5.5 |
    '---+------+------+-----+-----+-------+------'

=head2 OPTIONS

=head3 -f, --fields=LIST

select only these fields

=head3 -d, --delimiter=DELIM

use DELIM instead of TAB for field delimiter

=head3 --stderr

put result to STDERR(default: STDOUT)

=head3 -h, --help

display this help and exit

=head3 -v, --version

output version information and exit


=head1 AUTHOR

Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>


=head1 SEE ALSO

L<Statistics::Swoop>


=head1 LICENSE

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See L<perlartistic>.

=cut

